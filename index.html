<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Investigating Trends in NYT Articles</title>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <!-- fullPage.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/4.0.11/fullpage.min.css">
    <!-- Custom Styles -->
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="fullpage">
        <!-- Intro Section -->
        <div class="section" id="intro">
            <div id="intro-content">
                <h1>Investigating Trends in <i>The New York Times</i> Through Visualization</h1>
                <h2>By Ethan Brooks and Tamur Asar</h2>
                <p>The following visualizations were constructed using a collection
                    of over <a href="https://www.kaggle.com/datasets/aryansingh0909/nyt-articles-21m-2000-present"
                        target="_blank">two million New York Times articles</a>. They aim to illustrate common patterns,
                    be that cultural or semantic, that exist in NYT articles. While we do not have comprehensive datasets
                    for other news agencies to compare to, we aim to extrapolate our findings as an explanation to broader
                    news trends.
                </p>
            </div>
        </div>

        <!-- D3.js Treemap Section -->
        <div class="section">
            <div class="content-container">
                <h2>Which New York Times sections produce the most news?</h2>
                <!-- Year Selector -->
                <div class="year-selector">
                    <label for="year">Select Year:</label>
                    <select id="year"></select>
                </div>
                <!-- Treemap Container -->
                <div id="treemap"></div>
                <p>
                    This visualization, called a Treemap, shows the breakdown
                    of published articles by section for a given year. Treemaps
                    are effective at conveying how individual sections contribute to the total volume of published articles. By
                    interacting with the year selector, users can explore trends over time. For example, they might discover
                    growth in technology-related articles with the rise of the internet and digital culture. They might also
                    discover the New York section was common during the post-9/11 period, that the Business Day section rose
                    during the 2007 financial crisis, and that the World section rose during the 2003 Iraq War. Viewers may also
                    notice that some sections hold a relatively constant percentage makeup of total articles published, while
                    others fluctuate greatly year to year.
                </p>
            </div>
        </div>

        <!-- D3.js Word Cloud Section -->
        <div class="section">
            <div class="content-container">
                <h2>What were the most common words of each year?</h2>
                <!-- Year Selector -->
                <div class="year-selector">
                    <label for="wordcloud-year">Select Year:</label>
                    <select id="wordcloud-year"></select>
                </div>
                <!-- Word Cloud Container -->
                <div id="wordcloud"></div>
                <p>
                    "Hot topic" words can give us insights into the current events
                    of a given year. This word cloud shows for each year the top ten keywords that saw the largest percentage
                    increase in frequency of use from the previous year. We decided on a word cloud because it allows users to
                    visualize the growth of top keywords and compare them relative to others. The size of each word indicates the
                    magnitude of growth, making it easy to identify which topics have gained the most traction. As one might
                    expect, in 2001, the keywords 'New York City' and 'Terrorism' grew significantly from the previous year,
                    reflecting the impact of the September 11th attacks on public consciousness and media coverage. In 2003, we
                    see the prominence of keywords like 'Iraq', 'United States International Relations', and 'Housing',
                    coinciding with the Iraq War and the focus on real estate that foreshadowed the coming housing market crisis.
                    In 2008, 'Barack Obama' and 'United States Economy' surge in frequency, corresponding to Obama's election
                    campaign and the global financial crisis.
                </p>
            </div>
        </div>

        <!-- D3.js Line Chart Sentiment Trends Section -->
        <div class="section">
            <div class="content-container">
                <h2>Current events shape our news landscape - How do topical news events shift the tone of articles across
                    different sectors of news?</h2>
                <!-- Section Selector -->
                <div class="selector-container">
                    <label for="sectionSelect">Select Section:</label>
                    <select id="sectionSelect"></select>
                </div>
                <!-- Line Chart Container -->
                <div id="linechart"></div>
                <p>
                    This line chart illustrates the
                    average sentiment across various sections over time. We utilized sentiment analysis to gauge the emotional
                    tone of the articles in each section, presenting a clear picture of how the tone of news changes.
                    This visualization shows how different sections of news might respond to the same event. For example, the
                    September 11 attacks in 2001 and the financial crisis of 2008 led to significant shifts in sentiment across all
                    sections, highlighting how major events have a widespread impact on reporting.
                </p>
            </div>
        </div>

        <!-- D3.js Stacked Bar Chart Section -->
        <div class="section">
            <div class="content-container">
                <h2>
                    Which categories lean towards being the most negative? The most positive?
                </h2>
                <!-- Year Selector -->
                <div class="year-selector">
                    <label for="yearSelect">Select Year:</label>
                    <select id="yearSelect"></select>
                </div>
                <!-- Stacked Bar Chart Container -->
                <div id="stackedbarchart"></div>
                <p>
                    Here, we find the breakdown of tone for different sections, allowing for a straightforward comparative
                    analysis. Immediately you can recognize a trend in some of the bars. Perhaps most insightful is the category
                    for "World". Between 2000 and 2010, the category for World never has an overall negative sentiment quantifier
                    under fifty percent. That means, year over year, over fifty percent of world news articles published by The New
                    York Times focus on negative subjects. We can contrast this to a category such as "Travel" where the category
                    is overwhelmingly positive. This makes sense: travel news typically emphasizes the beauty of the world. In
                    contrast, the most commonly talked about world news subjects are international conflicts. At the time of
                    writing, opening The New York Times's World News page greets us with the Israel-Palestine conflict and the
                    Russia-Ukraine War. There are no positive world articles. Is that to say there is no positive world news? Or
                    that The New York Times provides what consumers seek, and people are looking for news about conflicts rather
                    than their resolutions.
                </p>
            </div>
        </div>

        <!-- Conclusion Section -->
        <div class="section">
            <div class="content-container">
                <h2>Conclusion</h2>
                <p>
                    Our visualizations have provided valuable
                    insights into the publishing trends, keyword growth, and sentiment dynamics of New York Times articles over
                    the years. By exploring the data through these visualizations, we can better understand how The New York
                    Times has responded to historical events, how public interests have shifted, and how the tone of news
                    reporting has evolved. We hope these visualizations inspire further exploration and analysis of media
                    trends, contributing to a deeper understanding of the factors that shape the news landscape.
                </p>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- D3 Word Cloud Layout -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.min.js"></script>
    <!-- fullPage.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/4.0.11/fullpage.min.js"></script>
    <!-- Initialize fullPage.js -->
    <script>
        new fullpage('#fullpage', {
            autoScrolling: true,
            navigation: true,
            navigationPosition: 'right',
            navigationTooltips: ['Intro', 'Section Production', 'Common Words', 'Sentiment Trends', 'Categories Sentiment', 'Conclusion'],
            showActiveTooltip: false,
            slidesNavigation: true,
            slidesNavPosition: 'bottom',
            scrollingSpeed: 700,
            css3: true,
            easing: 'easeInOutCubic',
        });
    </script>

    <!-- D3.js Treemap Script -->
    <script>
        // Set dimensions based on container size
        const treemapContainer = document.getElementById('treemap');
        const width = treemapContainer.clientWidth;
        const height = treemapContainer.clientHeight;

        // Create SVG for treemap
        const svg = d3.select("#treemap")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Load the CSV data
        d3.csv("data/treemap2000-11.csv").then(data => {
            // Convert numerical columns from strings to numbers
            data.forEach(d => {
                d['Count of nyt-metadata-cleaned-3.csv'] = +d['Count of nyt-metadata-cleaned-3.csv'];
                d['Year'] = +d['Year'];
            });

            // Extract and sort unique years for the dropdown
            const years = Array.from(new Set(data.map(d => d.Year))).sort((a, b) => a - b);
            const yearFilter = d3.select("#year");
            years.forEach(year => {
                yearFilter.append("option").text(year).attr("value", year);
            });

            // Function to update the treemap based on selected year
            function updateTreemap(selectedYear) {
                const filteredData = data.filter(d => d.Year == selectedYear);

                // Get max article count for color scaling
                const maxCount = d3.max(filteredData, d => d['Count of nyt-metadata-cleaned-3.csv']);

                // Define a color scale using a gradient (e.g., shades of blue)
                const colorScale = d3.scaleSequential()
                    .domain([0, maxCount])
                    .interpolator(d3.interpolateBlues);

                // Group data by section name and calculate total article count
                const sectionCounts = filteredData.map(d => ({
                    name: d['Section Name'],
                    value: d['Count of nyt-metadata-cleaned-3.csv']
                }));

                // Set up hierarchy and treemap layout
                const root = d3.hierarchy({ children: sectionCounts })
                    .sum(d => d.value)
                    .sort((a, b) => b.value - a.value);

                d3.treemap()
                    .size([width, height])
                    .padding(2)(root);

                // Bind data and create groups for each rectangle and label
                const nodes = svg.selectAll("g")
                    .data(root.leaves(), d => d.data.name);

                nodes.exit().remove();

                const nodeEnter = nodes.enter().append("g")
                    .attr("transform", d => `translate(${d.x0},${d.y0})`);

                // Append rectangles
                nodeEnter.append("rect")
                    .attr("class", "treemap-rect")
                    .attr("width", d => d.x1 - d.x0)
                    .attr("height", d => d.y1 - d.y0)
                    .style("fill", d => colorScale(d.value));

                // Append text labels
                nodeEnter.append("text")
                    .attr("class", "label")
                    .attr("x", d => (d.x1 - d.x0) / 2)
                    .attr("y", d => (d.y1 - d.y0) / 2)
                    .text(d => `${d.data.name}: ${d.value}`)
                    .call(wrapText, d => d.x1 - d.x0);

                // Update positions of existing nodes
                nodes.transition().duration(500)
                    .attr("transform", d => `translate(${d.x0},${d.y0})`);

                nodes.select("rect")
                    .transition().duration(500)
                    .attr("width", d => d.x1 - d.x0)
                    .attr("height", d => d.y1 - d.y0)
                    .style("fill", d => colorScale(d.value));

                nodes.select(".label")
                    .transition().duration(500)
                    .attr("x", d => (d.x1 - d.x0) / 2)
                    .attr("y", d => (d.y1 - d.y0) / 2)
                    .text(d => `${d.data.name}: ${d.value}`)
                    .call(wrapText, d => d.x1 - d.x0);

                // Add hover tooltip
                nodeEnter.append("title")
                    .text(d => `${d.data.name}\nArticles: ${d.value}`);
            }

            // Initial render with the first available year
            updateTreemap(years[0]);

            // Update the treemap when year filter changes
            yearFilter.on("change", () => {
                const selectedYear = yearFilter.property("value");
                updateTreemap(selectedYear);
            });
        });

        // Function to wrap text within a given width
        function wrapText(text, widthFunc) {
            text.each(function (d) {
                var text = d3.select(this),
                    words = text.text().split(/\s+/).reverse(),
                    width = widthFunc(d),
                    line = [],
                    lineNumber = 0,
                    lineHeight = 1.1, // ems
                    x = text.attr("x"),
                    y = text.attr("y"),
                    dy = 0,
                    tspan = text.text(null).append("tspan").attr("x", x).attr("y", y);
                var word;
                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if (tspan.node().getComputedTextLength() > width - 10) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan")
                            .attr("x", x)
                            .attr("y", y)
                            .attr("dy", ++lineNumber * lineHeight + "em")
                            .text(word);
                    }
                }
            });
        }
    </script>

    <!-- D3.js Word Cloud Script -->
    <script>
        // Set dimensions based on container size
        const wordcloudContainer = document.getElementById('wordcloud');
        const wcWidth = wordcloudContainer.clientWidth;
        const wcHeight = wordcloudContainer.clientHeight;
        const colorScale = d3.scaleOrdinal(d3.schemeTableau10);

        // Create SVG for word cloud
        const wcSvg = d3.select("#wordcloud")
            .append("svg")
            .attr("width", wcWidth)
            .attr("height", wcHeight)
            .append("g")
            .attr("transform", `translate(${wcWidth / 2}, ${wcHeight / 2})`);

        // Load the CSV data
        d3.csv("data/wordcloud_data.csv").then(data => {
            // Convert numerical columns from strings to numbers
            data.forEach(d => {
                d['Growth Percentage'] = +d['Growth Percentage'];
                d.Year = +d.Year;
            });

            // Extract and sort unique years for the dropdown
            const wcYears = Array.from(new Set(data.map(d => d.Year))).sort((a, b) => a - b);
            const wcYearFilter = d3.select("#wordcloud-year");
            wcYears.forEach(year => {
                wcYearFilter.append("option").text(year).attr("value", year);
            });

            // Function to update the word cloud based on selected year
            function updateWordCloud(selectedYear) {
                const filteredData = data.filter(d => d.Year == selectedYear);

                // Define font size scale
                const growthExtent = d3.extent(filteredData, d => d['Growth Percentage']);
                const fontSizeScale = d3.scaleLinear()
                    .domain(growthExtent)
                    .range([20, 100]); // Adjust font size range as needed

                const layout = d3.layout.cloud()
                    .size([wcWidth, wcHeight])
                    .words(filteredData.map(d => ({ text: d.Keyword, size: d['Growth Percentage'] })))
                    .padding(5)
                    .rotate(() => 0) // Set rotation to 0 for all words
                    .fontSize(d => fontSizeScale(d.size))
                    .on("end", draw);

                layout.start();

                function draw(words) {
                    wcSvg.selectAll("*").remove();
                    wcSvg.selectAll("text")
                        .data(words)
                        .enter().append("text")
                        .style("font-size", d => `${d.size}px`)
                        .style("fill", (d, i) => colorScale(i))
                        .attr("text-anchor", "middle")
                        .attr("transform", d => `translate(${d.x}, ${d.y}) rotate(${d.rotate})`)
                        .text(d => d.text);
                }
            }

            // Initial render with the first available year
            updateWordCloud(wcYears[0]);

            // Update the word cloud when year filter changes
            wcYearFilter.on("change", () => {
                const selectedYear = wcYearFilter.property("value");
                updateWordCloud(selectedYear);
            });
        }).catch(error => {
            console.error('Error loading or parsing data:', error);
        });
    </script>

    <!-- D3.js Line Chart Script -->
    <script>
        // Define margins and dimensions
        const margin = { top: 50, right: 100, bottom: 50, left: 60 };
        const lineChartContainer = document.getElementById('linechart');
        const lcWidth = lineChartContainer.clientWidth - margin.left - margin.right;
        const lcHeight = (lineChartContainer.clientHeight || 600) - margin.top - margin.bottom; // Default height if not set

        // Create SVG for line chart
        const lcSvg = d3.select("#linechart")
            .append("svg")
            .attr("width", lcWidth + margin.left + margin.right)
            .attr("height", lcHeight + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        const x = d3.scaleLinear().range([0, lcWidth]);
        const y = d3.scaleLinear().range([lcHeight, 0]);

        const colorMap = {
            "Positive": "green",
            "Neutral": "gray",
            "Negative": "red"
        };

        const line = d3.line()
            .x(d => x(d.year))
            .y(d => y(d.percentage));

        // Load the CSV data
        d3.csv("data/nyt_sentiment_filtered.csv").then(rawData => {
            // Convert Year to number
            rawData.forEach(d => {
                d.Year = +d.Year;
                d.Sentiment = d.Sentiment.split(": ")[1]; // Extract sentiment value
            });

            // Preprocess data to calculate sentiment percentages by year and section
            const data = [];
            const nestedData = d3.rollup(
                rawData,
                v => v.length,
                d => d.section_name,
                d => d.Year,
                d => d.Sentiment
            );

            // Prepare data for plotting
            const sentiments = ["Positive", "Neutral", "Negative"];
            const sections = Array.from(nestedData.keys()).sort();

            const plotData = {};

            sections.forEach(section => {
                const yearsMap = nestedData.get(section);
                const years = Array.from(yearsMap.keys()).sort();
                plotData[section] = sentiments.map(sentiment => {
                    return {
                        sentiment: sentiment,
                        values: years.map(year => {
                            const sentimentsMap = yearsMap.get(year);
                            const totalArticles = d3.sum(sentiments, s => sentimentsMap.get(s) || 0);
                            const count = sentimentsMap.get(sentiment) || 0;
                            return {
                                year: year,
                                percentage: totalArticles ? (count / totalArticles) * 100 : 0
                            };
                        })
                    };
                });
            });

            // Populate the section dropdown
            const sectionSelect = d3.select("#sectionSelect");

            sectionSelect.selectAll("option")
                .data(sections)
                .enter()
                .append("option")
                .text(d => d)
                .attr("value", d => d);

            x.domain([
                d3.min(rawData, d => d.Year),
                d3.max(rawData, d => d.Year)
            ]);
            y.domain([0, 100]); // Assuming percentages from 0 to 100

            // Function to update the chart
            const updateChart = section => {
                const dataToPlot = plotData[section];

                // Clear previous content
                lcSvg.selectAll(".axis").remove();
                lcSvg.selectAll(".line").remove();
                lcSvg.selectAll(".legend").remove();

                // Append X axis
                lcSvg.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${lcHeight})`)
                    .call(d3.axisBottom(x).tickFormat(d3.format("d")));

                // Append Y axis
                lcSvg.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(y));

                // Add X axis label
                lcSvg.append("text")
                    .attr("class", "axis-label")
                    .attr("x", lcWidth / 2)
                    .attr("y", lcHeight + 40)
                    .style("text-anchor", "middle")
                    .text("Year");

                // Add Y axis label
                lcSvg.append("text")
                    .attr("class", "axis-label")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -lcHeight / 2)
                    .attr("y", -50)
                    .style("text-anchor", "middle")
                    .text("Percentage (%)");

                // Draw lines
                lcSvg.selectAll(".line")
                    .data(dataToPlot)
                    .enter()
                    .append("path")
                    .attr("class", "line")
                    .attr("d", d => line(d.values))
                    .style("stroke", d => colorMap[d.sentiment])
                    .style("fill", "none")
                    .style("stroke-width", 2);

                // Add legend
                const legend = lcSvg.selectAll(".legend")
                    .data(sentiments)
                    .enter()
                    .append("g")
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(${lcWidth - 90}, ${i * 25})`);

                legend.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", d => colorMap[d]);

                legend.append("text")
                    .attr("x", 25)
                    .attr("y", 14)
                    .text(d => d);
            };

            sectionSelect.on("change", function () {
                const selectedSection = this.value;
                updateChart(selectedSection);
            });

            // Initial render with the first available section
            updateChart(sections[0]);
        }).catch(error => {
            console.error('Error loading or processing data:', error);
        });
    </script>

    <!-- D3.js Stacked Bar Chart Script -->
    <script>
        // Define margins and dimensions
        const sbMargin = { top: 50, right: 120, bottom: 100, left: 60 };
        const sbContainer = document.getElementById('stackedbarchart');
        const sbWidth = sbContainer.clientWidth - sbMargin.left - sbMargin.right;
        const sbHeight = (sbContainer.clientHeight || 600) - sbMargin.top - sbMargin.bottom;

        // Create SVG for stacked bar chart
        const sbSvg = d3.select("#stackedbarchart")
            .append("svg")
            .attr("width", sbWidth + sbMargin.left + sbMargin.right)
            .attr("height", sbHeight + sbMargin.top + sbMargin.bottom)
            .append("g")
            .attr("transform", `translate(${sbMargin.left}, ${sbMargin.top})`);

        // Define color scale for sentiments
        const sbColor = d3.scaleOrdinal()
            .domain(["Positive", "Neutral", "Negative"])
            .range(["green", "gray", "red"]);

        // Load the CSV data
        d3.csv("data/nyt_sentiment_filtered.csv").then(rawData => {
            // Convert Year to number
            rawData.forEach(d => {
                d.Year = +d.Year;
                d.Sentiment = d.Sentiment.split(": ")[1]; // Extract sentiment value
            });

            // Get the list of years
            const years = Array.from(new Set(rawData.map(d => d.Year))).sort((a, b) => a - b);

            // Populate the year dropdown
            const yearSelect = d3.select("#yearSelect");
            yearSelect.selectAll("option")
                .data(years)
                .enter()
                .append("option")
                .text(d => d)
                .attr("value", d => d);

            // Function to update the chart
            const updateBarChart = selectedYear => {
                // Filter data for the selected year
                const yearData = rawData.filter(d => d.Year === +selectedYear);

                // Aggregate data by section and sentiment
                const nestedData = d3.rollup(
                    yearData,
                    v => v.length,
                    d => d.section_name,
                    d => d.Sentiment
                );

                // Prepare data in required format
                const sections = Array.from(nestedData.keys());
                const sentiments = ["Positive", "Neutral", "Negative"];

                const data = sections.map(section => {
                    const sentimentCounts = nestedData.get(section) || new Map();
                    const total = d3.sum(sentiments, s => sentimentCounts.get(s) || 0);
                    return {
                        section: section,
                        Positive: (sentimentCounts.get("Positive") || 0) / total * 100,
                        Neutral: (sentimentCounts.get("Neutral") || 0) / total * 100,
                        Negative: (sentimentCounts.get("Negative") || 0) / total * 100,
                    };
                });

                // Sort sections alphabetically
                data.sort((a, b) => a.section.localeCompare(b.section));

                // Clear previous content
                sbSvg.selectAll("*").remove();

                // Set up scales
                const x = d3.scaleBand()
                    .domain(data.map(d => d.section))
                    .range([0, sbWidth])
                    .padding(0.2);

                const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([sbHeight, 0]);

                // Add X axis
                sbSvg.append("g")
                    .attr("transform", `translate(0, ${sbHeight})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");

                // Add Y axis
                sbSvg.append("g")
                    .call(d3.axisLeft(y));

                // Stack the data
                const stackedData = d3.stack()
                    .keys(sentiments)
                    (data);

                // Draw the bars
                sbSvg.selectAll(".serie")
                    .data(stackedData)
                    .enter().append("g")
                    .attr("class", "serie")
                    .attr("fill", d => sbColor(d.key))
                    .selectAll("rect")
                    .data(d => d)
                    .enter().append("rect")
                    .attr("x", d => x(d.data.section))
                    .attr("y", d => y(d[1]))
                    .attr("height", d => y(d[0]) - y(d[1]))
                    .attr("width", x.bandwidth())
                    .append("title")
                    .text(function(d) {
                        const sentiment = this.parentNode.__data__.key;
                        const percentage = (d[1] - d[0]).toFixed(2);
                        return `${d.data.section}\n${sentiment}: ${percentage}%`;
                    });

                // Add Y axis label
                sbSvg.append("text")
                    .attr("class", "axis-label")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -sbHeight / 2)
                    .attr("y", -50)
                    .style("text-anchor", "middle")
                    .text("Percentage (%)");

                // Add legend
                const legend = sbSvg.selectAll(".legend")
                    .data(sentiments)
                    .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(${sbWidth + 10}, ${i * 25})`);

                legend.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", sbColor);

                legend.append("text")
                    .attr("x", 25)
                    .attr("y", 14)
                    .style("text-anchor", "start")
                    .text(d => d);
            };
            // Initial render with the first available year
            updateBarChart(years[0]);

            // Update chart when year changes
            yearSelect.on("change", function () {
                const selectedYear = this.value;
                updateBarChart(selectedYear);
            });
        }).catch(error => {
            console.error('Error loading or processing data:', error);
        });
    </script>
</body>
</html>
